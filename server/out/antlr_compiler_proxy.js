"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
exports.antlrP4HeaderDec = new Map();
exports.antlrP4StructHeaders = new Map();
const antlr4_1 = require("antlr4");
const P4Lexer_1 = require("./antlr_autogenerated/P4Lexer");
const P4Parser_1 = require("./antlr_autogenerated/P4Parser");
const P4Listener_1 = require("./antlr_autogenerated/P4Listener");
const tree_1 = require("antlr4/tree");
function sendToAntlrCompiler(textDocument) {
    utils_1.loglog("Change in the code. Running Antlr Compiler");
    let input = textDocument.getText();
    var chars = new antlr4_1.InputStream(input);
    var lexer = new P4Lexer_1.P4Lexer(chars);
    lexer.strictMode = false; // do not use js strictMode
    var tokens = new antlr4_1.CommonTokenStream(lexer);
    var parser = new P4Parser_1.P4Parser(tokens);
    parser.buildParseTrees = true;
    var tree = parser.input();
    //******			DATA STRUCTURES
    ////Establishing symbol table -> installed package from https://www.npmjs.com/package/symbol-table (npm install symbol-table)
    var SymbolTable = require("symbol-table");
    var SymbolTableStack = require("symbol-table/stack");
    var symTableStack = SymbolTableStack();
    var typeDefMap = new Map();
    //types to size
    //type myTypeA int16
    //type myTypeB -> myTypeA
    //chapter 7 of basic data types in p4Spec
    //prepopulate with all the built in types
    const kvPairs = {
        'id': null,
        'TreeNode': null
    };
    const findSize = {
        'multiplier': 0,
        'size': 0
    };
    var maxSize = {
        'max': 0
    };
    var p4KeywordList = [
        "drop"
    ];
    //ERROR FUNCTIONS
    function undefVarAlert(value, arr) {
        if (arr.includes(value)) {
            return;
        }
        utils_1.logloglog("--->Error: undefined variable \"" + value + "\"");
    }
    //DEFS OF popSym and checkSym
    function popSym() {
        utils_1.logloglog("\n\npopSym():");
        utils_1.logloglog("------------------------------");
        var MyP4Listner = function (table) {
            P4Listener_1.P4Listener.call(this); // inherit default listener
            P4Listener_1.P4Listener.symTableStack = table;
            return this;
        };
        // continue inheriting default listener
        MyP4Listner.prototype = Object.create(P4Listener_1.P4Listener.prototype);
        MyP4Listner.prototype.constructor = MyP4Listner;
        function addSymbolTableEntry(stack, id, entry) {
            // logloglog("identifier: " + id);
            // logloglog("entry: " + entry.getText());
            // logloglog("stack height: " + stack.height());
            stack.set(id, entry);
        }
        //for testing purposes 
        //logloglog("kvPairs.id = " + kvPairs.id + " kvPairs.TreeNode = " + kvPairs.TreeNode.getText());
        //CONSTANT DECLARATION
        MyP4Listner.prototype.enterConstantDeclaration = function (ctx) {
            var id = ctx.getChild(3).getText();
            var entry = ctx;
            //addSymbolTableEntry(symTableStack, id, ctx);
        };
        //EXTERN DECLARATION
        P4Listener_1.P4Listener.prototype.enterExternDeclaration = function (ctx) {
            kvPairs.id = ctx.getChild(2).getText();
            kvPairs.TreeNode = ctx;
            //addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
            symTableStack.push();
        };
        P4Listener_1.P4Listener.prototype.exitExternDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //ACTION DECLARATION
        P4Listener_1.P4Listener.prototype.enterActionDeclaration = function (ctx) {
            var id = ctx.getChild(2).getText();
            addSymbolTableEntry(symTableStack, id, ctx); //adding entire node
            symTableStack.push();
        };
        MyP4Listner.prototype.exitActionDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //PARSER DECLARATION
        P4Listener_1.P4Listener.prototype.enterParserDeclaration = function (ctx) {
            //	logloglog("entering parser");
            kvPairs.TreeNode = ctx;
            P4Listener_1.P4Listener.prototype.enterParserTypeDeclaration = function (ctx) {
                kvPairs.id = ctx.getChild(2).getText();
                //	addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
                symTableStack.push();
            };
        };
        P4Listener_1.P4Listener.prototype.exitParserDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //TYPE DECLARATION
        MyP4Listner.prototype.enterTypeDeclaration = function (ctx) {
            MyP4Listner.prototype.enterTypedefDeclaration = function (ctx) {
                //I'm only going to store the size of the type def, ie typedef bit<99> will only store 99
                var id = ctx.getChild(3).getText(); //in grammar, name is 4th value in every case
                MyP4Listner.prototype.enterBaseType = function (ctx) {
                    var bits = ctx.getChild(2).getText(); //nodes are 'bit' '<' 'int' '>'
                    //logloglog("key: " + id + " value: " + bits);	//logging to show
                    typeDefMap.set(id, bits);
                };
            };
        };
        // CONTROL DECLARATION
        MyP4Listner.prototype.enterControlDeclaration = function (ctx) {
            var id = ctx.getChild(0).getText();
            var entry = ctx;
            addSymbolTableEntry(symTableStack, id, ctx);
            symTableStack.push();
        };
        MyP4Listner.prototype.exitControlDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //---TABLE DECLARATION
        MyP4Listner.prototype.enterTableDeclaration = function (ctx) {
            //logloglog("enter tabler");
            var id = ctx.getChild(2).getText();
            var entry = ctx;
            addSymbolTableEntry(symTableStack, id, ctx);
            symTableStack.push();
        };
        MyP4Listner.prototype.exitTableDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //INSTANTIATION
        P4Listener_1.P4Listener.prototype.enterInstantiation = function (ctx) {
            //Also ask professor Soule to explain this
            //logloglog("entering instantiation");
        };
        P4Listener_1.P4Listener.prototype.exitInstantiation = function (ctx) {
        };
        //ERROR DECLARATION
        P4Listener_1.P4Listener.prototype.enterErrorDeclaration = function (ctx) {
            kvPairs.id = ctx.getChild(0).getText(0);
            kvPairs.TreeNode = ctx;
            addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
            symTableStack.push();
        };
        P4Listener_1.P4Listener.prototype.exitErrorDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //MATCH_KIND DECLARATION
        P4Listener_1.P4Listener.prototype.enterMatchKindDeclaration = function (ctx) {
            //	logloglog("enteringMatchkind");
            //	logloglog(ctx.getText());
            kvPairs.id = ctx.getChild(0).getText(0);
            kvPairs.TreeNode = ctx;
            addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
            symTableStack.push();
        };
        P4Listener_1.P4Listener.prototype.exitMatchKindDeclaration = function (ctx) {
            symTableStack.pop();
        };
        //FUNCTION DECLARATION
        P4Listener_1.P4Listener.prototype.enterFunctionDeclaration = function (ctx) {
            // //ASK PROF SOULE
            // logloglog("enteringFunctionDeclaration");
            // logloglog(ctx.getChild(0).getText());
            kvPairs.TreeNode = ctx;
        };
        P4Listener_1.P4Listener.prototype.exitFunctionDeclaration = function (ctx) {
        };
        //HEADER DECLARATION
        P4Listener_1.P4Listener.prototype.enterHeaderTypeDeclaration = function (ctx) {
            var id = ctx.getChild(2).getText();
            var values = (ctx.getChild(4));
            typeDefMap.set(id, values);
            //"name" -> struct
            var type = ctx.getChild(1).getText();
            var name = ctx.getChild(2).getText();
            typeDefMap.set(name, type);
            utils_1.logloglog("entering: " + name + " with type: " + type);
            utils_1.logloglog("entering: " + id + " with values: " + values.getText());
            P4Listener_1.P4Listener.prototype.enterStructFieldList = function (ctx) {
                P4Listener_1.P4Listener.prototype.enterStructField = function (ctx) {
                    var id2 = ctx.getChild(2).getText();
                    MyP4Listner.prototype.enterBaseType = function (ctx) {
                        var bits = (ctx.getChild(2).getText()); //nodes are 'bit' '<' 'int' '>'
                        typeDefMap.set(id, bits);
                        utils_1.logloglog("entering: " + id2 + " with bits: " + bits);
                    };
                };
            };
        };
        //STRUCT DECLARATION
        // Enter a parse tree produced by P4Parser#structTypeDeclaration.
        P4Listener_1.P4Listener.prototype.enterStructTypeDeclaration = function (ctx) {
            var id = ctx.getChild(2).getText();
            var values = ctx.getChild(4);
            typeDefMap.set(id, values);
            //"name" -> struct
            var type = ctx.getChild(1).getText();
            var name = ctx.getChild(2).getText();
            typeDefMap.set(name, type);
            utils_1.logloglog("entering: " + id + " with values: " + values.getText());
            utils_1.logloglog("entering: " + name + " with type: " + type);
            P4Listener_1.P4Listener.prototype.enterStructFieldList = function (ctx) {
                P4Listener_1.P4Listener.prototype.enterStructField = function (ctx) {
                    var id2 = ctx.getChild(2).getText();
                    MyP4Listner.prototype.enterBaseType = function (ctx) {
                        var bits = (ctx.getChild(2).getText()); //nodes are 'bit' '<' 'int' '>'
                        typeDefMap.set(id, bits);
                        utils_1.logloglog("entering: " + id2 + " with bits: " + bits);
                    };
                };
            };
        };
        // Exit a parse tree produced by P4Parser#structTypeDeclaration.
        P4Listener_1.P4Listener.prototype.exitStructTypeDeclaration = function (ctx) {
        };
        // Exit a parse tree produced by P4Parser#headerTypeDeclaration.
        P4Listener_1.P4Listener.prototype.exitHeaderTypeDeclaration = function (ctx) {
        };
        var myP4Listner = new MyP4Listner(symTableStack);
        try {
            tree_1.ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
        }
        catch (e) { }
        return symTableStack;
    }
    function getResources(map, id) {
        var node = map.get(id);
        utils_1.logloglog(node.getChild(2).getText());
        utils_1.logloglog(typeof node.getChild(2));
    }
    function checkSym(populatedSym) {
        utils_1.logloglog("\n\n\nStarting checkSym......");
        utils_1.logloglog("------------------------------");
        var MyP4Listner = function (table) {
            P4Listener_1.P4Listener.call(this); // inherit default listener
            P4Listener_1.P4Listener.symTableStack = table;
            return this;
        };
        // continue inheriting default listener
        MyP4Listner.prototype = Object.create(P4Listener_1.P4Listener.prototype);
        MyP4Listner.prototype.constructor = MyP4Listner;
        // ***		action declaration
        MyP4Listner.prototype.enterActionDeclaration = function (ctx) {
            // Enter a parse tree produced by P4Parser#parameterList.
            MyP4Listner.prototype.enterParameterList = function (ctx) {
                MyP4Listner.prototype.enterParameter = function (ctx) {
                    if (typeDefMap.has(ctx.getChild(2).getText())) { //CAN IMPROVE!!!!!
                        utils_1.logloglog("typedef has: " + ctx.getChild(2).getText());
                        utils_1.logloglog(typeDefMap.get(ctx.getChild(2).getText()));
                        findSize.size += Number(typeDefMap.get(ctx.getChild(2).getText()));
                        //getResources(typeDefMap, ctx.getChild(2).getText());
                    }
                    else {
                        utils_1.logloglog("not found");
                    }
                    if (findSize.size > maxSize.max) {
                        maxSize.max = findSize.size; //in order to ensure the maximum size;
                    }
                };
            };
        };
        MyP4Listner.prototype.exitActionDeclaration = function (ctx) {
            findSize.size = 0; //reset findSize
        };
        MyP4Listner.prototype.enterControlDeclaration = function (ctx) {
            //code for handling tables
            MyP4Listner.prototype.enterTableDeclaration = function (ctx) {
                MyP4Listner.prototype.enterTableProperty = function (ctx) {
                    //logloglog("table property: " + ctx.getText());
                    //Only want to get action ref if it's inside table property
                    MyP4Listner.prototype.enterActionRef = function (ctx) {
                        if (populatedSym.getItsHeight(ctx.getText()) == undefined) {
                            undefVarAlert(ctx.getText(), p4KeywordList);
                        }
                    };
                    //Only want Kw names inside of table properties
                    MyP4Listner.prototype.enterNonTableKwName = function (ctx) {
                        P4Listener_1.P4Listener.prototype.enterInitializer = function (ctx) {
                            if (Number.isInteger(Number(ctx.getText()))) { //change to if kwName belongs to size!!!!!!
                                findSize.multiplier = Number(ctx.getText()); //setting the multiplier for findSize
                            }
                        };
                    };
                };
            };
            //code for handling apply
            P4Listener_1.P4Listener.prototype.enterControlBody = function (ctx) {
                P4Listener_1.P4Listener.prototype.enterStatOrDeclList = function (ctx) {
                    P4Listener_1.P4Listener.prototype.enterStatementOrDeclaration = function (ctx) {
                        P4Listener_1.P4Listener.prototype.enterStatement = function (ctx) {
                            P4Listener_1.P4Listener.prototype.enterConditionalStatement = function (ctx) {
                                //getting deep, ASK PROF SOULE
                                //logloglog("apply statement: " + ctx.getText());
                            };
                        };
                    };
                };
            };
        };
        var myP4Listner = new MyP4Listner(symTableStack);
        try {
            tree_1.ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
        }
        catch (e) { }
        //return "no errors";
        utils_1.logloglog("TOTAL RESOURCES: " + findSize.multiplier * maxSize.max);
    }
    /*                              CALLING                               */
    popSym(); //executing symbol table population
    checkSym(symTableStack); //executing symbol table checking
}
exports.sendToAntlrCompiler = sendToAntlrCompiler;
//# sourceMappingURL=antlr_compiler_proxy.js.map