"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const utils_1 = require("./utils");
exports.antlrP4HeaderDec = new Map();
exports.antlrP4StructHeaders = new Map();
const antlr4_1 = require("antlr4");
const error_1 = require("antlr4/error");
const P4Lexer_1 = require("./antlr_autogenerated/P4Lexer");
const P4Parser_1 = require("./antlr_autogenerated/P4Parser");
const P4Listener_1 = require("./antlr_autogenerated/P4Listener");
const tree_1 = require("antlr4/tree");
const server_1 = require("./server");
let MyP4Listner = function () {
    P4Listener_1.P4Listener.call(this); // inherit default listener
    return this;
};
// continue inheriting default listener
MyP4Listner.prototype = Object.create(P4Listener_1.P4Listener.prototype);
MyP4Listner.prototype.constructor = MyP4Listner;
////symbol table -> installed package from https://www.npmjs.com/package/symbol-table (npm install symbol-table)
var SymbolTable = require("symbol-table");
//pointers array (no pointers in Javascript but this will act like it)
var symPtrs = [];
//pushing global scope to the top of the pointer array
symPtrs.push(SymbolTable());
MyP4Listner.prototype.enterConstantDeclaration = function (ctx) {
    utils_1.logloglog("enter constant: " + ctx.getText());
};
MyP4Listner.prototype.exitConstantDeclaration = function (ctx) {
    utils_1.logloglog("exit CONSTANT");
};
MyP4Listner.prototype.enterControlDeclaration = function (ctx) {
};
MyP4Listner.prototype.enterAssignmentOrMethodCallStatement = function (ctx) {
    // loglog("Assign: " + ctx.getText());
};
function sendToAntlrCompiler(textDocument) {
    utils_1.loglog("Running Antlr Compiler");
    let myP4Listner = new MyP4Listner();
    let errorListener = new MyErrorListner(textDocument);
    let tree = setupLexerAndParser(textDocument, errorListener);
    try {
        tree_1.ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
    }
    catch (e) { }
    if (!errorListener.isEmpty()) {
        let diagnostics = errorListener.getDiagnostics();
        server_1.connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
    }
}
exports.sendToAntlrCompiler = sendToAntlrCompiler;
function setupLexerAndParser(textDocument, errorListener) {
    let input = textDocument.getText();
    let chars = new antlr4_1.InputStream(input);
    let lexer = new P4Lexer_1.P4Lexer(chars);
    lexer.strictMode = false; // do not use js strictMode
    let tokens = new antlr4_1.CommonTokenStream(lexer);
    let parser = new P4Parser_1.P4Parser(tokens);
    parser.removeErrorListeners(); // Remove default ConsoleErrorListener
    parser.addErrorListener(errorListener); // Add custom error listener
    parser.buildParseTrees = true;
    let tree = parser.input();
    return tree;
}
class MyErrorListner extends error_1.ErrorListener {
    constructor(text) {
        super();
        this.diagnostics = [];
        this.textDocument = text;
    }
    isEmpty() {
        return this.diagnostics.length == 0;
    }
    getDiagnostics() {
        return this.diagnostics;
    }
    syntaxError(recognizer, symbol, line, column, message, payload) {
        let diagnosic = this.convertToDiagnostic(symbol, message);
        this.diagnostics.push(diagnosic);
    }
    convertToDiagnostic(symbol, message) {
        let diagnosic = {
            severity: vscode_languageserver_1.DiagnosticSeverity.Error,
            range: {
                start: this.textDocument.positionAt(symbol.start),
                end: this.textDocument.positionAt(symbol.stop),
            },
            message: message,
            source: 'P4 Extension'
        };
        return diagnosic;
    }
}
//# sourceMappingURL=antlr_compiler_proxy.js.map