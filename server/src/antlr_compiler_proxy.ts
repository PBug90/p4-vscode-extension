
//                 WORKING FOR DEBUGGING PURPOSES     
import {
	TextDocument,
	Diagnostic,
	DiagnosticSeverity,
	CompletionItemKind,
	DidChangeTextDocumentNotification,
} from 'vscode-languageserver';

import { loglog , logloglog } from './utils';


export let antlrP4HeaderDec: Map<string, any[]> = new Map();
export let antlrP4StructHeaders: Map<string, string> = new Map();

import { CommonTokenStream, InputStream} from 'antlr4';

import { P4Lexer } from './antlr_autogenerated/P4Lexer';
import { P4Parser } from './antlr_autogenerated/P4Parser';
import { P4Listener } from './antlr_autogenerated/P4Listener';
import { ParseTreeWalker } from 'antlr4/tree';
import { SIGUSR1 } from 'constants';
import { EOF } from 'dns';


export function sendToAntlrCompiler(textDocument: TextDocument){
	loglog("Change in the code. Running Antlr Compiler");

	let input : string = textDocument.getText();
	var chars = new InputStream(input);
	var lexer = new P4Lexer(chars);

	lexer.strictMode = false; // do not use js strictMode

	var tokens = new CommonTokenStream(lexer);
	var parser = new P4Parser(tokens);
	parser.buildParseTrees = true;
	var tree = parser.input();

	//******			DATA STRUCTURES

	////Establishing symbol table -> installed package from https://www.npmjs.com/package/symbol-table (npm install symbol-table)
	var SymbolTable = require("symbol-table");
	var SymbolTableStack = require("symbol-table/stack");
	var symTableStack = SymbolTableStack();

	var typeDefMap = new Map();

	//types to size
	//type myTypeA int16
	//type myTypeB -> myTypeA
	//chapter 7 of basic data types in p4Spec

	//prepopulate with all the built in types

	const kvPairs = {
		'id': null,
		'TreeNode': null
	};

	const findSize = {
		'multiplier': 0,
		'size': 0
	};


	var maxSize = {
		'max': 0
	};

	var p4KeywordList = [
		"drop"
	];
	//ERROR FUNCTIONS
	function undefVarAlert(value, arr){
		if (arr.includes(value)){
			return;
		}
		logloglog("--->Error: undefined variable \"" + value + "\"");
	}



	//DEFS OF popSym and checkSym
	function popSym(){
		logloglog("\n\npopSym():");
		logloglog("------------------------------");
		var MyP4Listner = function(table) : void {
			P4Listener.call(this); // inherit default listener
			P4Listener.symTableStack = table;
			return this;
		};
	
		// continue inheriting default listener
		MyP4Listner.prototype = Object.create(P4Listener.prototype);
		MyP4Listner.prototype.constructor = MyP4Listner;
		
		function addSymbolTableEntry(stack, id, entry) {
			// logloglog("identifier: " + id);
			// logloglog("entry: " + entry.getText());
			// logloglog("stack height: " + stack.height());
			stack.set(id, entry); 
		}


		//for testing purposes 
		//logloglog("kvPairs.id = " + kvPairs.id + " kvPairs.TreeNode = " + kvPairs.TreeNode.getText());

		//CONSTANT DECLARATION
		MyP4Listner.prototype.enterConstantDeclaration = function(ctx) {
			var id = ctx.getChild(3).getText();
			var entry = ctx;
			//addSymbolTableEntry(symTableStack, id, ctx);
		};

		//EXTERN DECLARATION
		P4Listener.prototype.enterExternDeclaration = function(ctx) {
			kvPairs.id = ctx.getChild(2).getText();
			kvPairs.TreeNode = ctx;
			//addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
			symTableStack.push();
		};
		P4Listener.prototype.exitExternDeclaration = function(ctx) {
			symTableStack.pop();
		};

		//ACTION DECLARATION
		P4Listener.prototype.enterActionDeclaration = function(ctx) {
			var id = ctx.getChild(2).getText();
			addSymbolTableEntry(symTableStack, id, ctx);	//adding entire node
			symTableStack.push();
		};

		MyP4Listner.prototype.exitActionDeclaration = function(ctx) {
			symTableStack.pop();  
		};

		//PARSER DECLARATION
		P4Listener.prototype.enterParserDeclaration = function(ctx) {
		//	logloglog("entering parser");
			kvPairs.TreeNode = ctx;
			P4Listener.prototype.enterParserTypeDeclaration = function(ctx) {
				kvPairs.id = ctx.getChild(2).getText();
			//	addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
				symTableStack.push();
			};
		};
		P4Listener.prototype.exitParserDeclaration = function(ctx) {
			symTableStack.pop();
		};


		//TYPE DECLARATION
		MyP4Listner.prototype.enterTypeDeclaration = function(ctx) {
			MyP4Listner.prototype.enterTypedefDeclaration = function(ctx) {
				//I'm only going to store the size of the type def, ie typedef bit<99> will only store 99
				var id = ctx.getChild(3).getText(); //in grammar, name is 4th value in every case
				MyP4Listner.prototype.enterBaseType = function(ctx) {
					var bits = ctx.getChild(2).getText(); 	//nodes are 'bit' '<' 'int' '>'
					//logloglog("key: " + id + " value: " + bits);	//logging to show
					typeDefMap.set(id, bits);
				};
			};
		};


		// CONTROL DECLARATION
		MyP4Listner.prototype.enterControlDeclaration = function(ctx) {
			var id = ctx.getChild(0).getText();
			var entry = ctx;
			addSymbolTableEntry(symTableStack, id, ctx);
			symTableStack.push();  
		};
	
		MyP4Listner.prototype.exitControlDeclaration = function(ctx) {
			symTableStack.pop();  
		};
		
		//---TABLE DECLARATION
		MyP4Listner.prototype.enterTableDeclaration = function(ctx) {
			//logloglog("enter tabler");
			var id = ctx.getChild(2).getText();
			var entry = ctx;
			addSymbolTableEntry(symTableStack, id, ctx);
			symTableStack.push();  
		};
	
		MyP4Listner.prototype.exitTableDeclaration = function(ctx) {
			symTableStack.pop();  
		};


		//INSTANTIATION
		P4Listener.prototype.enterInstantiation = function(ctx) {
			//Also ask professor Soule to explain this
			//logloglog("entering instantiation");
		};
		
		P4Listener.prototype.exitInstantiation = function(ctx) {
		};

		//ERROR DECLARATION
		P4Listener.prototype.enterErrorDeclaration = function(ctx) {
			kvPairs.id = ctx.getChild(0).getText(0);
			kvPairs.TreeNode = ctx;
			addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
			symTableStack.push();
		};

		P4Listener.prototype.exitErrorDeclaration = function(ctx) {
			symTableStack.pop();
		};

		//MATCH_KIND DECLARATION
		P4Listener.prototype.enterMatchKindDeclaration = function(ctx) {
		//	logloglog("enteringMatchkind");
		//	logloglog(ctx.getText());
			kvPairs.id = ctx.getChild(0).getText(0);
			kvPairs.TreeNode = ctx;
			addSymbolTableEntry(symTableStack, kvPairs.id, kvPairs.TreeNode);
			symTableStack.push();
		};

		P4Listener.prototype.exitMatchKindDeclaration = function(ctx) {
			symTableStack.pop();
		};
		
		//FUNCTION DECLARATION
		P4Listener.prototype.enterFunctionDeclaration = function(ctx) {
			// //ASK PROF SOULE
			// logloglog("enteringFunctionDeclaration");
			// logloglog(ctx.getChild(0).getText());
			kvPairs.TreeNode = ctx;
		};

		P4Listener.prototype.exitFunctionDeclaration = function(ctx) {
		};


		//HEADER DECLARATION
		P4Listener.prototype.enterHeaderTypeDeclaration = function(ctx) {
			var id = ctx.getChild(2).getText();
			var values = (ctx.getChild(4));
			typeDefMap.set(id, values);

			//"name" -> struct
			var type = ctx.getChild(1).getText();
			var name = ctx.getChild(2).getText();
			typeDefMap.set(name, type);
			logloglog("entering: " + name + " with type: " + type);
			logloglog("entering: " + id + " with values: " + values.getText());
			P4Listener.prototype.enterStructFieldList = function(ctx) {
				P4Listener.prototype.enterStructField = function(ctx) {
					var id2 = ctx.getChild(2).getText();
					MyP4Listner.prototype.enterBaseType = function(ctx) {
						var bits = (ctx.getChild(2).getText()); 	//nodes are 'bit' '<' 'int' '>'
						typeDefMap.set(id, bits);
						logloglog("entering: " + id2 + " with bits: " + bits);
					};
				};
			};
		};

		//STRUCT DECLARATION
		// Enter a parse tree produced by P4Parser#structTypeDeclaration.
		P4Listener.prototype.enterStructTypeDeclaration = function(ctx) {
			var id = ctx.getChild(2).getText();
			var values = ctx.getChild(4);
			typeDefMap.set(id, values);

			//"name" -> struct
			var type = ctx.getChild(1).getText();
			var name = ctx.getChild(2).getText();
			typeDefMap.set(name, type);
			logloglog("entering: " + id + " with values: " + values.getText());
			logloglog("entering: " + name + " with type: " + type);
			P4Listener.prototype.enterStructFieldList = function(ctx) {
				P4Listener.prototype.enterStructField = function(ctx) {
					var id2 = ctx.getChild(2).getText();
					MyP4Listner.prototype.enterBaseType = function(ctx) {
						var bits = (ctx.getChild(2).getText()); 	//nodes are 'bit' '<' 'int' '>'
						typeDefMap.set(id, bits);
						logloglog("entering: " + id2 + " with bits: " + bits);
					};
				};
			};
		};

		// Exit a parse tree produced by P4Parser#structTypeDeclaration.
		P4Listener.prototype.exitStructTypeDeclaration = function(ctx) {
		};
		
		// Exit a parse tree produced by P4Parser#headerTypeDeclaration.
		P4Listener.prototype.exitHeaderTypeDeclaration = function(ctx) {
		};

		var myP4Listner = new MyP4Listner(symTableStack);
		try{
			ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
		} catch(e){}

		return symTableStack;
	}
	
	function getResources(map, id){
		var node = map.get(id);
		logloglog(node.getChild(2).getText());
		logloglog(typeof node.getChild(2));
		
	}
	function checkSym(populatedSym){
		logloglog("\n\n\nStarting checkSym......");
		logloglog("------------------------------");
		var MyP4Listner = function(table) : void {
			P4Listener.call(this); // inherit default listener
			P4Listener.symTableStack = table;
			return this;
		};

		// continue inheriting default listener
		MyP4Listner.prototype = Object.create(P4Listener.prototype);
		MyP4Listner.prototype.constructor = MyP4Listner;

		// ***		action declaration
		MyP4Listner.prototype.enterActionDeclaration = function(ctx) {
			
			// Enter a parse tree produced by P4Parser#parameterList.
			MyP4Listner.prototype.enterParameterList = function(ctx) {

				MyP4Listner.prototype.enterParameter = function(ctx){
					if (typeDefMap.has(ctx.getChild(2).getText())){	//CAN IMPROVE!!!!!

						logloglog("typedef has: " + ctx.getChild(2).getText());
						logloglog(typeDefMap.get(ctx.getChild(2).getText()));

						findSize.size += Number(typeDefMap.get(ctx.getChild(2).getText()));
						//getResources(typeDefMap, ctx.getChild(2).getText());
					} else {
						logloglog("not found");
					}

					if (findSize.size > maxSize.max){
						maxSize.max = findSize.size;	//in order to ensure the maximum size;
					}
					
				};
			};
		};

		MyP4Listner.prototype.exitActionDeclaration = function(ctx) {
			findSize.size = 0; //reset findSize
		};

		MyP4Listner.prototype.enterControlDeclaration = function(ctx) {
			
			//code for handling tables
			MyP4Listner.prototype.enterTableDeclaration = function(ctx){

				MyP4Listner.prototype.enterTableProperty = function(ctx) {
					//logloglog("table property: " + ctx.getText());
					
					//Only want to get action ref if it's inside table property
					MyP4Listner.prototype.enterActionRef = function(ctx) {
						if (populatedSym.getItsHeight(ctx.getText()) == undefined){		
							undefVarAlert(ctx.getText(), p4KeywordList);
						}
						
					};

					//Only want Kw names inside of table properties
					MyP4Listner.prototype.enterNonTableKwName = function(ctx) {
						P4Listener.prototype.enterInitializer = function(ctx) {	//Required traversal to get to size
							if (Number.isInteger(Number(ctx.getText()))){	//change to if kwName belongs to size!!!!!!
								findSize.multiplier = Number(ctx.getText());	//setting the multiplier for findSize
							}
						};
					};
				};
			};


			//code for handling apply
			P4Listener.prototype.enterControlBody = function(ctx) {

				P4Listener.prototype.enterStatOrDeclList = function(ctx) {

					P4Listener.prototype.enterStatementOrDeclaration = function(ctx) {

						P4Listener.prototype.enterStatement = function(ctx) {

							P4Listener.prototype.enterConditionalStatement = function(ctx) {
								//getting deep, ASK PROF SOULE
								//logloglog("apply statement: " + ctx.getText());
							};
						};
					};
				};
			};
		};

		

		var myP4Listner = new MyP4Listner(symTableStack);
		try{
			ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
		} catch(e){}
		//return "no errors";

		logloglog("TOTAL RESOURCES: " + findSize.multiplier*maxSize.max);
	}




	/*                              CALLING                               */


	popSym(); //executing symbol table population
	checkSym(symTableStack);	//executing symbol table checking
}