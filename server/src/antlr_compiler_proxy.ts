
//                 WORKING FOR DEBUGGING PURPOSES     
import {
	TextDocument,
	Diagnostic,
	DiagnosticSeverity,
	CompletionItemKind,
	DidChangeTextDocumentNotification,
} from 'vscode-languageserver';

import { loglog , logloglog } from './utils';


export let antlrP4HeaderDec: Map<string, any[]> = new Map();
export let antlrP4StructHeaders: Map<string, string> = new Map();

import { CommonTokenStream, InputStream} from 'antlr4';

import { P4Lexer } from './antlr_autogenerated/P4Lexer';
import { P4Parser } from './antlr_autogenerated/P4Parser';
import { P4Listener } from './antlr_autogenerated/P4Listener';
import { ParseTreeWalker } from 'antlr4/tree';
import { SIGUSR1 } from 'constants';
import { EOF } from 'dns';


export function sendToAntlrCompiler(textDocument: TextDocument){
	loglog("Change in the code. Running Antlr Compiler");

	let input : string = textDocument.getText();
	var chars = new InputStream(input);
	var lexer = new P4Lexer(chars);

	lexer.strictMode = false; // do not use js strictMode

	var tokens = new CommonTokenStream(lexer);
	var parser = new P4Parser(tokens);
	parser.buildParseTrees = true;
	var tree = parser.input();

	//******			DATA STRUCTURES

	////Establishing symbol table -> installed package from https://www.npmjs.com/package/symbol-table (npm install symbol-table)
	var SymbolTable = require("symbol-table");
	var SymbolTableStack = require("symbol-table/stack");
	var symTableStack = SymbolTableStack();

	var typeDefMap = new Map();
	//types to size
	//type myTypeA int16
	//type myTypeB -> myTypeA
	//chapter 7 of basic data types in p4Spec

	//prepopulate with all the built in types


	//ERROR FUNCTIONS
	function undefVarAlert(value){
		logloglog("--->Error: undefined variable \"" + value + "\"");
	}



	//DEFS OF popSym and checkSym
	function popSym(){
		logloglog("\n\npopSym():");
		logloglog("------------------------------");
		var MyP4Listner = function(table) : void {
			P4Listener.call(this); // inherit default listener
			P4Listener.symTableStack = table;
			return this;
		};
	
		// continue inheriting default listener
		MyP4Listner.prototype = Object.create(P4Listener.prototype);
		MyP4Listner.prototype.constructor = MyP4Listner;
		
		function addSymbolTableEntry(stack, id, entry) {
			logloglog("identifier: " + id);
			logloglog("entry: " + entry.getText());
			logloglog("stack height: " + stack.height());
			stack.set(id, entry); 
		}



		//CONSTANT DECLARATION

		MyP4Listner.prototype.enterConstantDeclaration = function(ctx) {
			var id = ctx.getChild(3).getText();
			var entry = ctx;
			addSymbolTableEntry(symTableStack, id, ctx);
		};


		// ***		type declaration
		MyP4Listner.prototype.enterTypeDeclaration = function(ctx) {
			MyP4Listner.prototype.enterTypedefDeclaration = function(ctx) {
				//I'm only going to store the size of the type def, ie typedef bit<99> will only store 99
				var id = ctx.getChild(3).getText(); //in grammar, name is 4th value in every case
				MyP4Listner.prototype.enterBaseType = function(ctx) {
					var bits = ctx.getChild(2).getText(); 	//nodes are 'bit' '<' 'int' '>'
					logloglog("key: " + id + " value: " + bits);	//logging to show
					typeDefMap.set(id, bits);
				};
			};
		};


		//ACTION DECLARATION

		P4Listener.prototype.enterActionDeclaration = function(ctx) {
			var id = ctx.getChild(2).getText();
			addSymbolTableEntry(symTableStack, id, ctx);	//adding entire node
			symTableStack.push();
		};

		MyP4Listner.prototype.exitActionDeclaration = function(ctx) {
			symTableStack.pop();  
		};

		//PARSER DECLARATION

		// Enter a parse tree produced by P4Parser#parserDeclaration.
		P4Listener.prototype.enterParserDeclaration = function(ctx) {
			P4Listener.prototype.enterParserTypeDeclaration = function(ctx) {
				
			};
			// Exit a parse tree produced by P4Parser#parserTypeDeclaration.
			P4Listener.prototype.exitParserTypeDeclaration = function(ctx) {
			};
		};
		// Exit a parse tree produced by P4Parser#parserDeclaration.
		P4Listener.prototype.exitParserDeclaration = function(ctx) {
		};




		// CONTROL DECLARATION


		MyP4Listner.prototype.enterControlDeclaration = function(ctx) {
			var id = ctx.getChild(0).getText();
			var entry = ctx;
			addSymbolTableEntry(symTableStack, id, ctx);
			symTableStack.push();  
		};
	
		MyP4Listner.prototype.exitControlDeclaration = function(ctx) {
			symTableStack.pop();  
		};
		

		//TABLE DEC

		// Enter a parse tree produced by P4Parser#tableDeclaration.
		MyP4Listner.prototype.enterTableDeclaration = function(ctx) {
			logloglog("enter table");
			var id = ctx.getChild(2).getText();
			var entry = ctx;
			addSymbolTableEntry(symTableStack, id, ctx);
			symTableStack.push();  
		};
	
		MyP4Listner.prototype.exitTableDeclaration = function(ctx) {
			symTableStack.pop();  
		};
	
		var myP4Listner = new MyP4Listner(symTableStack);
		try{
			ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
		} catch(e){}

		return symTableStack;
	}
	
	function getResources(map, id){
		var node = map.get(id);
		logloglog(node.getChild(2).getText());
		logloglog(typeof node.getChild(2));
		
	}
	function checkSym(populatedSym){
		logloglog("\n\n\nStarting checkSym......");
		logloglog("------------------------------");
		var MyP4Listner = function(table) : void {
			P4Listener.call(this); // inherit default listener
			P4Listener.symTableStack = table;
			return this;
		};

		// ***		action declaration
		P4Listener.prototype.enterActionDeclaration = function(ctx) {
			
			// Enter a parse tree produced by P4Parser#parameterList.
			P4Listener.prototype.enterParameterList = function(ctx) {

				P4Listener.prototype.enterParameter = function(ctx){
					if (typeDefMap.has(ctx.getChild(2).getText())){	//CAN IMPROVE!!!!!
						logloglog("typedef has: " + ctx.getChild(2).getText());
						getResources(typeDefMap, ctx.getChild(2).getText());
					} else {
						logloglog("not found");
					}
				};
			};
		};

		MyP4Listner.prototype.exitActionDeclaration = function(ctx) {
			symTableStack.pop();  
		};


		// continue inheriting default listener
		MyP4Listner.prototype = Object.create(P4Listener.prototype);
		MyP4Listner.prototype.constructor = MyP4Listner;

		MyP4Listner.prototype.enterControlDeclaration = function(ctx) {
			
			//ASK PROF SOULE ABOUT THE DEPTH HE WANTS!!!!!!!!!!!!

			//code for handling tables
			MyP4Listner.prototype.enterTableDeclaration = function(ctx){

				MyP4Listner.prototype.enterTableProperty = function(ctx) {
					logloglog("table property: " + ctx.getText());

					//Only want to get action ref if it's inside table property
					MyP4Listner.prototype.enterActionRef = function(ctx) {
						if (populatedSym.getItsHeight(ctx.getText()) == undefined){
							if (ctx.getText() == "NoAction"){ //if ctx.getText().includes keyword, continue
								//ask Prof. Soule about this
									//create a keyword list!!!!!!!!!!! 
								logloglog("--->OK, I think \"NoAction\" doesn't qualify as a use.");
							} else {
								undefVarAlert(ctx.getText());
							}
						}
					};

					//Only want Kw names inside of table properties
					MyP4Listner.prototype.enterNonTableKwName = function(ctx) {
						logloglog("kwName: " + ctx.getText());
						P4Listener.prototype.enterInitializer = function(ctx) {
							logloglog("kwNameValue: " + ctx.getText());
							//Ask prof soule about drop and how to distinguish it!!!
						};
					};
				};
			};

			//code for handling apply
			P4Listener.prototype.enterControlBody = function(ctx) {

				P4Listener.prototype.enterStatOrDeclList = function(ctx) {

					P4Listener.prototype.enterStatementOrDeclaration = function(ctx) {

						P4Listener.prototype.enterStatement = function(ctx) {

							P4Listener.prototype.enterConditionalStatement = function(ctx) {
								//getting deep, ASK PROF SOULE
								logloglog("apply statement: " + ctx.getText());
							};
						};
					};
				};
			};
		};

		var myP4Listner = new MyP4Listner(symTableStack);
		try{
			ParseTreeWalker.DEFAULT.walk(myP4Listner, tree);
		} catch(e){}
		//return "no errors";
	}




	/*                              CALLING                               */


	popSym(); //executing symbol table population
	checkSym(symTableStack);	//executing symbol table checking
}
	
/*	I want to save this


	var symTablePass = new SymbolTablePass(symTableStack);
	
	ParseTreeWalker.DEFAULT.walk(symTablePass, tree);
	try{
		//ParseTreeWalker.DEFAULT.walk(symTablePass, tree);	
	} catch(e){}

	var symTableCheck = new SymbolTableCheck(symTableStack);
	ParseTreeWalker.DEFAULT.walk(symTableCheck, tree);	
	try{
		//ParseTreeWalker.DEFAULT.walk(symTableCheck, tree);
	} catch(e){}
*/



