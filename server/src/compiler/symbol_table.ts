import { P4Listener } from '../antlr_autogenerated/P4Listener';
import { logDebug, logInfo, logError} from '../utils/logger';
import Stack from '../utils/stack';
import { P4IR, Attribute } from './p4_ir';
import { P4IRTypes } from './p4_ir_types';
import { TextDocumentPositionParams, CompletionItem } from 'vscode-languageserver';

export class SymbolTable{
	SYMBOL_STACK: Stack<P4IR>;
	SYMBOL_ARR: Array<P4IR>;

	constructor(){
		this.SYMBOL_STACK = new Stack();
		this.SYMBOL_ARR = new Array<P4IR>();
	}

	getAutoCompletion(keyword: string, pos: TextDocumentPositionParams): CompletionItem[] {
		logDebug("keyword: " + keyword);
		let lineNumber: number = pos.position.line;

		let tmpMin: number = Number.MAX_VALUE;
		let tmpP4Ir: P4IR | null = null;
		for (let p4Ir of this.SYMBOL_ARR) {
			if(p4Ir.isInsideMe(lineNumber)){
				if(p4Ir.length() < tmpMin){
					tmpMin = p4Ir.length();
					tmpP4Ir = p4Ir;
				}	
			}
		}

		if(tmpP4Ir){
			logInfo("I'm not empty: " + tmpP4Ir);
		}else{
			logInfo("not found: " + lineNumber);
		}
		
		return [];
	}

	private sym_add(p: P4IR): void {
		// TODO
		this.SYMBOL_ARR.push(p);
	}

	add_attr(name: string, attr: Attribute): void{
		let topTable:P4IR = this.SYMBOL_STACK.peek();
		if(topTable)
			this.SYMBOL_STACK.peek().add(name, attr);
		else
			logError("Error: Symbole table is null!");
	}

	push(ctx, type: P4IRTypes): P4IR {
		let p: P4IR = this.SYMBOL_STACK.peek();
		let newP: P4IR = new P4IR(type, p, ctx);
		this.SYMBOL_STACK.push(newP);
		this.sym_add(newP);

		return newP;
	}

	pop(): P4IR{
		return this.SYMBOL_STACK.pop();
	}
}