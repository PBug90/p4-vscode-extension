import { P4Listener } from "../antlr_autogenerated/P4Listener";
import {
  ConstantDeclarationContext,
  ProgramContext,
} from "../antlr_autogenerated/P4Parser";
import ASTNode, { BlockScoped, IdentifierNode, ProgramNode } from "./ASTNode";

export default class MyP4Listener extends P4Listener {
  private currentNode: ASTNode;
  private nodeStack: ASTNode[] = [];
  private currentScopeNode: BlockScoped = null;
  private types: Record<string, unknown> = null;

  getTree() {
    return this.nodeStack.pop();
  }

  peek() {
    return this.nodeStack[this.nodeStack.length - 1];
  }

  enterProgram(ctx: ProgramContext) {
    const node = new ProgramNode("Program");
    this.currentScopeNode = node;
    this.nodeStack.push(node);
  }

  enterPpIncludeFileName(ctx) {
    const node = new ASTNode("Include Filename");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitPpIncludeFileName() {
    this.nodeStack.pop();
  }

  enterHeaderTypeDeclaration(ctx) {
    const node = new ASTNode("Header Type Declaration");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitHeaderTypeDeclaration(ctx) {
    this.nodeStack.pop();
  }

  enterName(ctx) {
    // this.peek().addChild(new ASTNode(ctx.getText()));
  }

  enterInitializer(ctx) {
    this.peek().addChild(new ASTNode(ctx.getText()));
  }

  enterTypeName(ctx) {
    //this.peek().addChild(new ASTNode(ctx.getText()));
  }

  enterBaseType(ctx) {
    const node = new ASTNode(ctx.getText());
    this.peek().addChild(node);
  }

  enterStructTypeDeclaration(ctx) {
    const node = new ASTNode("Struct Type Declaration");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitStructTypeDeclaration(ctx) {
    this.nodeStack.pop();
  }

  enterConstantDeclaration(ctx: ConstantDeclarationContext) {
    const node = new ASTNode("ConstantDeclaration");
    this.nodeStack[this.nodeStack.length - 1].addChild(node);
    this.nodeStack.push(node);
  }

  exitConstantDeclaration(ctx) {
    this.nodeStack.pop();
  }

  enterStructField(ctx) {
    const node = new ASTNode("StructField");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitStructField(ctx) {
    this.nodeStack.pop();
  }

  enterControlDeclaration(ctx) {
    const node = new ASTNode("ControlDeclaration");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitControlDeclaration(ctx) {
    this.nodeStack.pop();
  }

  enterParameterList(ctx) {
    const node = new ASTNode("ParameterList");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitParameterList(ctx) {
    this.nodeStack.pop();
  }

  enterParameter(ctx) {
    const node = new ASTNode("Parameter");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitParameter() {
    this.nodeStack.pop();
  }

  enterDirection(ctx) {
    const node = new ASTNode(ctx.getText());
    this.peek().addChild(node);
  }

  enterActionDeclaration(ctx) {
    const node = new ASTNode("ActionDeclaration");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitActionDeclaration() {
    this.nodeStack.pop();
  }

  enterBlockStatement() {
    const node = new ASTNode("Block");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitBlockStatement() {
    this.nodeStack.pop();
  }

  enterAssignmentOrMethodCallStatement(ctx) {
    const node = new ASTNode("AssignmentOrMethodCall");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitAssignmentOrMethodCallStatement() {
    this.nodeStack.pop();
  }

  enterTableDeclaration() {
    const node = new ASTNode("TableDeclaration");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitTableDeclaration() {
    this.nodeStack.pop();
  }

  enterTableProperty(ctx) {
    const node = new ASTNode("TableProperty", {
      line: ctx.start.line,
      start: ctx.start.start,
      end: ctx.start.stop,
    });
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }
  exitTableProperty() {
    this.nodeStack.pop();
  }

  enterKeyElement(ctx) {
    const node = new ASTNode("KeyElement");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitKeyElement() {
    this.nodeStack.pop();
  }

  enterActionRef() {
    const node = new ASTNode("ActionRef");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitActionRef() {
    this.nodeStack.pop();
  }

  enterControlBody(ctx) {
    const node = new ASTNode("ControlBody");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitControlBody() {
    this.nodeStack.pop();
  }

  enterVariableDeclaration() {
    const node = new ASTNode("VariableDeclaration");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitVariableDeclaration() {
    this.nodeStack.pop();
  }

  enterDirectApplication() {
    const node = new ASTNode("DirectApplication");
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitDirectApplication() {
    this.nodeStack.pop();
  }

  enterExpression(ctx) {
    const node = new ASTNode("Expression", {
      line: ctx.start.line,
      start: ctx.start.start,
      end: ctx.start.stop,
    });
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitExpression() {
    this.nodeStack.pop();
  }

  enterNonTypeName(ctx) {
    //const node = new ASTNode(ctx.getText());
    //this.peek().addChild(node);
  }

  enterPrefixedType(ctx) {
    //const node = new ASTNode("prefixed " + ctx.getText());
    //this.peek().addChild(node);
  }

  enterTypedefDeclaration(ctx) {
    const node = new ASTNode("TypeDeclaration", {
      line: ctx.start.line,
      start: ctx.start.start,
      end: ctx.start.stop,
    });
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }

  exitTypedefDeclaration(ctx) {
    this.nodeStack.pop();
  }

  enterType_or_id(ctx) {
    const node = new IdentifierNode(ctx.getText(), {
      line: ctx.start.line,
      start: ctx.start.start,
      end: ctx.start.stop,
    });
    this.peek().addChild(node);
  }

  enterLvalue(ctx) {
    let type = "unknown L Value";
    if (ctx.children.length > 1) {
      const token = ctx.children[1].getText();
      if (token === ".") {
        type = "PropertyAccess";
      }
    } else if (ctx.children.length === 1) {
      type = "PrefixedNonTypeName";
    }
    const node = new ASTNode(type, {
      line: ctx.start.line,
      start: ctx.start.start,
      end: ctx.start.stop,
    });
    this.peek().addChild(node);
    this.nodeStack.push(node);
  }
  exitLvalue(ctx) {
    this.nodeStack.pop();
  }
}
